Here's a breakdown of the key information from the "Computer Networks Chapter 3" document:Chapter 3: Datalink LayerFunctionalities:EncapsulationAddressingError detection and correctionFlow controlMedia access controlOverview of Data Link LayerLink LayerNodes: hosts and routersLinks: communication channels connecting adjacent nodesTypes of links: wired, wireless, LANsLayer-2 packet: frame, encapsulates datagramResponsibility: transferring datagram from one node to physically adjacent node over a linkDatalink Layer in Layer ArchitectureApplicationTransportNetworkData-linkPhysicalSub-layers:LLC (Logical Link Control)MAC (Media Access Control)Media dependent sub-layerIEEE 802.x series: 802.2 LLC, 802.3 Ethernet, 802.4 Token Bus, 802.5 Token Ring, 802.11 Wi-Fi, 802.16 Wi-MaxLink Layer ContextDatagram transfer: different link protocols over different links (e.g., WiFi, Ethernet)Each link protocol provides different services (e.g., reliable data transfer)Transportation analogy:Tourist = datagramTransport segment = communication linkTransportation mode = link-layer protocolTravel agent = routing algorithmLink Layer ServicesFraming, link access: encapsulate datagram into frame, adding header, trailerChannel access if shared mediumMAC addresses in frame headers (different from IP address)Media access control protocol for nodes sharing common mediaFlow control: pacing between adjacent sending and receiving nodesError detection: detecting errors caused by signal attenuation, noise; receiver signals retransmission or drops frameError correction: receiver identifies and corrects bit error(s) without retransmissionHalf-duplex and full-duplex: nodes at both ends can transmit, but not at the same time in half-duplexImplementationImplemented in each hostImplemented in Network Interface Card (NIC) or on a chip (Ethernet, WiFi)Implements link, physical layerAttaches into host's system busesCombination of hardware, software, firmwareInterfaces CommunicatingSending side: encapsulates datagram in frame, adds error checking bits, reliable data transfer, flow controlReceiving side: looks for errors, reliable data transfer, flow control, extracts datagram, passes to upper layerIdentifier: MAC Address48-bit address, organized by IEEEEach port has one MAC addressCannot be changedPhysical addressNo hierarchical system, flexibleUnchanged when changing networksBroadcast address in LAN: FF-FF-FF-FF-FF-FFError ControlError detectionError correctionPrinciple of Error DetectionEDC: error detection and correction bits (redundancy)D: data protected by error checkingProtocol may miss some errors, but rarelyLarger EDC field yields better detection and correctionParity CodeA check bit is added to the original data to ensure that the total number of bit 1 is even (even parity code) or odd (odd parity code)Single code: Able to detect single bit errorTwo-dimension code: Detect and correct single bit errorApplication: mainly on hardware, e.g., PCI and SCSI busChecksumGoal: detect errors (flipped bits) in transmitted segmentSender:Divides data into n-bit segmentsCalculates sum of segments; adds overflow bits to resultsChecksum: one's complement sum of segment contentReceiver:Divides data into n-bit segmentsCalculates sum of segments; adds overflow bits to resultsAdds received checksum to the resultsChecks final outcome: 0 indicates error detected, only 1 indicates no error, but errors may still existChecksum ExampleExample calculation and verification processCyclic Redundancy Check (CRC)More powerful error-detection codingD: data bits, G: bit pattern (generator) of r+1 bitsGoal: choose r CRC bits, R, such that <D,R> is exactly divisible by G (mod 2)Receiver divides <D,R> by G; non-zero remainder indicates errorCan detect all burst errors less than r+1 bitsWidely used (Ethernet, 802.11 WiFi)CRC: How to Find RFormula: R = D.2^r mod GExample calculationCRC Under Polynomial FormRepresentation of bit patterns as polynomials (e.g., 1011 <-> x^3 + x + 1)Examples of CRC generators: CRC-8, CRC-12, CRC-16-CCITT, CRC-32Longer G increases error detection capabilityUsed in Wi-Fi, ATM, EthernetXOR operation implemented in hardwareCapable of detecting errors less than r+1 bitsCRC ExamplesExamples of CRC calculation, sending, checking with no errors, and checking with errors.Reaction When Errors DetectedObjective: ensure correct data reception despite unreliable channelConstraint: Data frame must be correctly received with negligible transmission delayPossible errors: whole frame loss, error frame, loss of error warning messagePopular techniques: error detection, acknowledgement/confirmation, retransmissionARQ (Automatic Repeat Request) techniques:Stop and Wait ARQGo Back N ARQSelective Reject ARQSimilar to techniques used in flow controlStop-and-Wait ARQNormal case and error ACK/NAK caseACK packet carries #Seq of the packet to be acknowledgedAn ACK with acknowledgment number n implicitly confirms that all packet with #seq number <=n have been well receivedStop-and-Wait ARQ: When ACK is LostSender starts timer after sending packetSender re-sends packet when timeout expiresTimeout should be at least 1 RTT (Round Trip Time)Duplicate packets are eliminated at receiver using sequence numbersARQ with TimeoutDiagrams illustrating ARQ with timeoutFlow ControlGoal: prevent sender from overloading receiverWhy overloading? Receiver stores data frame in buffer, performs processing; buffer may become fullProblem assumes no transmission errors and small propagation timeSolutions: Stop-and-wait mechanism, sliding window mechanismStop-and-Wait (Flow Control)Principles: transmitter sends single frame, waits for ACK from receiver before sending next frameDiagram of stop-and-waitStop-and-Wait (Advantages and Weaknesses)Advantages: simple, suitable for large framesWeaknesses: inefficient for small frames, not suitable for very large frames (buffer limitations, error probability), inconvenient for shared mediumSliding Window: PrincipleTransmitter sends multiple frames without waiting for ACK to reduce waiting timeTransmitted frames without ACK are stored in bufferNumber of frames sent without ACK depends on transmitter buffer sizeTransmitter removes successfully transmitted frames from buffers upon receiving ACKTransmitter continues sending frames based on number of successfully transmitted framesSliding Window: AcknowledgementFrame numbering is necessary to track ACKed framesReceiver acknowledges a frame by indicating the next expected frame, implicitly acknowledging all preceding framesOne ACK can acknowledge multiple framesSliding Windows: PrincipleWindow lists frames to transmit and frames waiting for acknowledgementSliding WindowsFrames are numbered; maximum number must not be smaller than window sizeFrames are ACKed by another message with numberAccumulated ACK:  If frame 1,2,3,4 are received well, receiver acknowledges frame 5.